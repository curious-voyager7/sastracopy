<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Code Clipboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* Copying all styles from Clipboard.css */
        .clipboard-page {
            background-color: #f8f9fa;
            min-height: 100vh;
            padding-top: 20px;
        }

        .clipboard-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .clipboard-container h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        .notebook {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cell {
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .markdown-cell {
            background-color: #f8f9fa;
            padding: 10px 20px;
        }

        .markdown-content {
            font-weight: bold;
            font-size: 1.2rem;
            color: #2c3e50;
        }

        .code-cell {
            display: flex;
            flex-direction: column;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background-color: #f1f1f1;
            border-bottom: 1px solid #e0e0e0;
        }

        .copy-button {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .copy-button:hover {
            background-color: #45a049;
        }

        .copy-button.copied {
            background-color: #2196F3;
        }

        .code-content {
            background-color: #f8f8f8;
            padding: 15px;
            margin: 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .code-title {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 5px 0;
        }

        /* Stealth mode styles */
        .clipboard-page.stealth-mode {
            background-color: white;
            color: white;
        }

        .clipboard-page.stealth-mode * {
            color: white !important;
            background-color: white !important;
            border-color: white !important;
            box-shadow: none !important;
            outline: none !important;
        }

        .stealth-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
            display: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        .clipboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .stealth-toggle {
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="clipboard-page" id="clipboardPage">
        <div class="stealth-indicator" id="stealthIndicator">
            Stealth Mode: OFF
        </div>
        <div class="clipboard-container">
            <div class="clipboard-header">
                <h1>Static Code Clipboard</h1>
                <div class="stealth-toggle" id="stealthToggle">
                    <i class="fas fa-eye"></i>
                </div>
            </div>
            <div class="notebook" id="notebook">
                <!-- Content will be dynamically populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        const notebookData = [
            { type: 'markdown', content: '##A-Star' },
            { type: 'code', content: `def get(graph, a, b=None):
    links = graph.setdefault(a, {})
    if b is None:
        return links
    else:
        return links.get(b, float('inf'))

class Node:
    def __init__(self, name: str, parent=None):
        self.name = name
        self.parent = parent
        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.name == other.name

    def __lt__(self, other):
        return self.f < other.f

    def __repr__(self):
        return f"({self.name}, {self.f})"

def add_to_open(open_list, neighbor):
    for node in open_list:
        if neighbor == node and neighbor.f >= node.f:
            return False
    return True

def astar_search(graph, heuristics, start, end):
    open_list = []
    closed_list = []
    start_node = Node(start, None)
    goal_node = Node(end, None)
    open_list.append(start_node)
    while len(open_list) > 0:
        open_list.sort()
        current_node = open_list.pop(0)
        closed_list.append(current_node)
        if current_node == goal_node:
            path = []
            while current_node is not None:
                path.append(f"{current_node.name}:{current_node.g}")
                current_node = current_node.parent
            return path[::-1]
        neighbors = graph.get(current_node.name, {})
        for key, value in neighbors.items():
            neighbor = Node(key, current_node)
            if neighbor in closed_list:
                continue
            neighbor.g = current_node.g + get(graph, current_node.name, neighbor.name)
            neighbor.h = heuristics.get(neighbor.name, float('inf'))
            neighbor.f = neighbor.g + neighbor.h
            if add_to_open(open_list, neighbor):
                open_list.append(neighbor)
    return None

def input_graph():
    graph = {}
    print("Enter edges in the format 'from to cost' (type 'done' to finish):")
    while True:
        line = input("Edge: ")
        if line.lower() == 'done':
            break
        u, v, w = line.split()
        w = int(w)
        graph.setdefault(u, {})[v] = w
    return graph

def input_heuristics():
    heuristics = {}
    print("Enter heuristic values in the format 'node cost' (type 'done' to finish):")
    while True:
        line = input("Heuristic: ")
        if line.lower() == 'done':
            break
        node, cost = line.split()
        heuristics[node] = int(cost)
    return heuristics

if __name__ == "__main__":
    graph = input_graph()
    heuristics = input_heuristics()
    start = input("Enter the start node: ")
    goal = input("Enter the goal node: ")
    path = astar_search(graph, heuristics, start, goal)
    if path:
        print("Path found:")
        print(" -> ".join(path))
    else:
        print("No path found between the given nodes.")` },
            { type: 'markdown', content: '##All Path Finder' },
            { type: 'code', content: `def all_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    if start not in graph:
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            new_paths = all_paths(graph, node, end, path)
            for new_path in new_paths:
                paths.append(new_path)
    return paths

def input_graph():
    graph = {}
    print("Enter the graph (enter 'done' when finished):")
    while True:
        node = input("Enter a node (or 'done' to finish): ")
        if node.lower() == 'done':
            break
        connections = input(f"Enter connections from node {node} (comma-separated): ").split(',')
        connections = [c.strip() for c in connections if c.strip()]
        graph[node] = connections
    return graph

print("Graph Path Finder")
graph = input_graph()
start_node = input("Enter the start node: ")
end_node = input("Enter the end node: ")
result_paths = all_paths(graph, start_node, end_node)
print(f"\nAll paths from {start_node} to {end_node}:")
if not result_paths:
    print("No paths found")
else:
    for i, path in enumerate(result_paths, 1):
        print(f"{i}. {path}")` },
            { type: 'markdown', content: '##Alpha-Beta' },
            { type: 'code', content: `import math
nodes_visited = []
MAX, MIN = 1000, -1000

def minimax(cur_depth, node_index, max_turn, scores, target_depth, b_factor, alpha, beta):
    if cur_depth == target_depth:
        return scores[node_index]
    if max_turn:
        largest = None
        for i in range(b_factor):
            index = node_index * b_factor + i
            if index >= len(scores):
                continue
            cur = minimax(cur_depth + 1, index, False, scores, target_depth, b_factor, alpha, beta)
            if largest is None or cur > largest:
                largest = cur
            alpha = max(alpha, largest)
            nodes_visited.append(cur)
            if beta <= alpha:
                break
        return largest
    else:
        smallest = None
        for i in range(b_factor):
            index = node_index * b_factor + i
            if index >= len(scores):
                continue
            cur = minimax(cur_depth + 1, index, True, scores, target_depth, b_factor, alpha, beta)
            if smallest is None or cur < smallest:
                smallest = cur
            beta = min(beta, smallest)
            nodes_visited.append(cur)
            if beta <= alpha:
                break
        return smallest

scores = [int(s) for s in input("Enter the scores: ").split()]
b_factor = int(input("Enter the branching factor: "))
player = int(input("Maximizer or minimizer? (Enter 1 for maximizer and 0 for minimizer): "))
tree_depth = math.ceil(math.log(len(scores), b_factor))
print("The optimal value is:", end="")
print(minimax(0, 0, player, scores, tree_depth, b_factor, MIN, MAX))
diff = []
for i in scores:
    if i not in nodes_visited:
        diff.append(i)
if not diff:
    print("No nodes were pruned")
else:
    print("Pruned nodes are:")
    for i in diff:
        print(i, sep='')` },
            { type: 'markdown', content: '##BFS' },
            { type: 'code', content: `from collections import deque

def bfs(graph, start, goal):
    q = deque([(start, [start])])
    visited = set()
    trav_seq = []

    while q:
        node, path = q.popleft()
        if node not in visited:
            visited.add(node)
            trav_seq.append(node)

            if node == goal:
                return trav_seq, path

            for adj in graph.get(node, []):
                if adj not in visited:
                    q.append((adj, path + [adj]))
    return trav_seq, None

if __name__ == "__main__":
    print("Enter edges in format: a b (type 'done' to finish)")
    graph = {}

    while True:
        edge = input("Edge: ")
        if edge.lower() == 'done':
            break
        u, v= edge.split()
        graph.setdefault(u, []).append(v)

    start_node = input("Start node: ")
    end_node = input("Goal node: ")

    traversal, path = bfs(graph, start_node, end_node)

    print("\nBFS Traversal Sequence:", traversal)
    if path:
        print("Solution Path:", path)
    else:
        print("No path found from", start_node, "to", end_node)` },
            { type: 'markdown', content: '##Crossover (genetic)' },
            { type: 'code', content: `def crossover(s1, s2, start, end):
    s1 = str(s1)
    s2 = str(s2)
    s1_list = list(s1)
    s2_list = list(s2)

    s1_list[start:end], s2_list[start:end] = s2_list[start:end], s1_list[start:end]

    child_s1 = ''.join(s1_list)
    child_s2 = ''.join(s2_list)

    return child_s1, child_s2
s1 = int(input("Enter the first parent: "))
s2 = int(input("Enter the second parent: "))
start = int(input("Enter the start index: "))
end = int(input("Enter the end index: "))
child_s1, child_s2 = crossover(s1, s2, start, end)
print(f"Original s1: {s1}, Original s2: {s2}")
print(f"Child s1: {child_s1}, Child s2: {child_s2}")` },
            { type: 'markdown', content: '##CSP' },
            { type: 'code', content: `% pip install python-constraint
from IPython import get_ipython
from IPython.display import display
import constraint

x_min = int(input("Enter minimum value for x : "))
x_max = int(input("Enter maximum value for x : "))
y_min = int(input("Enter minimum value for y : "))
y_max = int(input("Enter maximum value for y : "))

problem = constraint.Problem()
problem.addVariable('x', range(x_min, x_max + 1))
problem.addVariable('y', range(y_min, y_max + 1))

def our_constraint(x,y):
    if x+y >= 20:
        return True

problem.addConstraint(our_constraint, ['x','y'])
solutions = problem.getSolutions()
length = len(solutions)
print("(x,y) =\\n", end = "")
for index, solution in enumerate(solutions):
    print("({},{})".format(solution['x'], solution['y']), end="")
    if index == length - 1:
        break
    print(",")
print("}")` },
            { type: 'markdown', content: '##Crypt_Arithematic' },
            { type: 'code', content: `import itertools

def get_value(word, substitution):
    s = 0
    factor = 1
    for letter in reversed(word):
        s += factor * substitution[letter]
        factor *= 10  # Fix: Multiply factor by 10
    return s

def solve2(equation):
    left, right = equation.lower().replace(' ', '').split('=') # Fix: Remove spaces
    left = left.split('+')
    letters = set(right)
    for word in left:
        for letter in word:
            letters.add(letter)
    letters = list(letters)
    digits = range(10)
    for perm in itertools.permutations(digits, len(letters)):
        sol = dict(zip(letters, perm))
        if sum(get_value(word, sol) for word in left) == get_value(right, sol):
            print('+'.join(str(get_value(word, sol)) for word in left) + " = {} (mapping: {})".format(get_value(right, sol), sol))

# Get user input
equation = input("Enter the cryptarithmetic equation (e.g., SEND+MORE=MONEY): ")
solve2(equation)` },
            { type: 'markdown', content: '##DFS Goal' },
            { type: 'code', content: `import networkx as nx
import matplotlib.pyplot as plt

def dfs(graph, start, goal, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = [start]

    visited.add(start)
    if start == goal:
        return path

    for neighbor in graph[start]:
      if neighbor not in visited:
        new_path = dfs(graph, neighbor, goal, visited, path + [neighbor])
        if new_path:
          return new_path

    return None

def visualize_graph_dfs(graph, path=None):
    G = nx.DiGraph()

    for node, neighbors in graph.items():
        for neighbor in neighbors:
            G.add_edge(node, neighbor)

    pos = nx.spring_layout(G)

    plt.figure(figsize=(6, 6))
    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=15, font_weight='bold', edge_color='gray')

    if path:
        path_edges = list(zip(path, path[1:]))
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2.5)

    plt.title("DFS Path Visualization")
    plt.show()


def get_graph_input() -> dict[str, list[str]]:
  n = int(input("Enter number of vertices: "))
  graph = {}
  for i in range(n):
    d = input("Enter node value and connected vertices: ")
    v, *c = d.split()
    graph[v] = c
  return graph


graph=get_graph_input()
start_node = input('Enter the starting node:')
goal_node = input('Enter the Goal node:')
path = dfs(graph, start_node, goal_node)

if path:
    print(f"DFS path from {start_node} to {goal_node}: {' -> '.join(path)}")
    visualize_graph_dfs(graph, path)
else:
    print(f"No path found from {start_node} to {goal_node}")` },
            { type: 'markdown', content: '##DFS TRAVERSAL' },
            { type: 'code', content: `def dfs_traversal(graph,start,visited):
  visited[start]=True
  print(start,end=" ")
  for i in graph[start]:
    if visited[i]==False:
      dfs_traversal(graph,i,visited)

def get_graph_input() -> dict[str, list[str]]:
  n = int(input("Enter number of vertices: "))
  graph = {}
  for i in range(n):
    d = input("Enter node value and connected vertices: ")
    v, *c = d.split()
    graph[v] = c
  return graph

graph=get_graph_input()
start_node = input('Enter the starting node:')
visited = {}
for i in graph:
  visited[i]=False
print(f"Traversal from {start_node} :")
path = dfs_traversal(graph, start_node,visited)` },
            { type: 'markdown', content: '##Graph Connection' },
            { type: 'code', content: `def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph.get(node, []):
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

def is_connected(graph):
    nodes = list(graph.keys())
    if not nodes:
        return True
    visited = set()
    dfs(graph, nodes[0], visited)
    return len(visited) == len(nodes)

def get_graph_from_user():
    graph = {}
    n = int(input("Enter the number of Nodes: "))

    for _ in range(n):
        node = input("Enter the node name: ")
        neighbors = input(f"Enter the neighbors of {node} (comma-separated): ").split(",")
        neighbors = [neighbor.strip() for neighbor in neighbors]
        graph[node] = neighbors

    print(graph)
    if is_connected(graph):
        print("The graph is connected.")
    else:
        print("The graph is disconnected.")


get_graph_from_user()` },
            { type: 'markdown', content: '##Kronecker Problem' },
            { type: 'code', content: `ra=int(input("enter no of rows"))
ca=int(input("enter no of columns"))
a=[]
for i in range(ra):
  row = []
  for j in range(ca):
    xa=int(input("enter element"))
    row.append(xa)
  a.append(row)
rb=int(input("enter no of rows"))
cb=int(input("enter no of columns"))
b=[]
for i in range(rb):
  row=[]
  for j in range(cb):
    xb=int(input("enter element"))
    row.append(xb)
  b.append(row)
res=[]
for ia in a:
  for ea in ia:
    temp=[]
    for ib in b:
      for eb in ib:
        temp.append(ea*eb)
    res.append(temp)
print(res)` },
            { type: 'markdown', content: '##Magic Square' },
            { type: 'code', content: `r=int(input("enter odd no of rows and columns"))
a=[]
for i in range(r):
  row = []
  for j in range(r):
    x=int(input("enter element"))
    row.append(x)
  a.append(row)

def res(a):
  T= r*(r**2 + 1)/2
  sumr=0
  sumc=0
  sumd1=0
  sumd2=0
  for i in range(r):
    sumd1+=a[i][i]
    sumd2+=a[i][r-i-1]
  if not(sumd1==sumd2):
    return False
  for j in range(r):
    sumr+=a[i][j]
    sumc+=a[j][i]
  if sumr==sumc==sumd1==sumd2==T:
    return True
  else:
    return False

magic=res(a)
if magic:
  print("IT IS MAGIC SQUARE")
else:
  print("NOT MAGIC SQUARE")` },
            { type: 'markdown', content: '##M-Coloring' },
            { type: 'code', content: `def is_safe(graph, color, vertex, c):
    for i in range(len(graph)):
        if graph[vertex][i] == 1 and color[i] == c:
            return False
    return True

def m_coloring_util(graph, m, color, vertex):
    if vertex == len(graph):
        return True

    for c in range(1, m + 1):
        if is_safe(graph, color, vertex, c):
            color[vertex] = c

            if m_coloring_util(graph, m, color, vertex + 1):
                return True

            color[vertex] = 0

    return False

def m_coloring(graph, m):
    color = [0] * len(graph)
    if m_coloring_util(graph, m, color, 0):
        print("Solution:")
        for i in range(len(color)):
            print(f"Vertex {i}: Color {color[i]}")
    else:
        print("No solution exists")


num_vertices = int(input("Enter the number of vertices: "))
graph = []
print("Enter the adjacency matrix (space-separated values for each row):")
for _ in range(num_vertices):
    row = list(map(int, input().split()))
    graph.append(row)

print("Graph:")
for row in graph:
    print(row)

M = 3
m_coloring(graph, M)` },
            { type: 'markdown', content: '##Mice and Hole Problem' },
            { type: 'code', content: `k=[]
c=[]
n=int(input("enter how many kids:"))
print("enter the positions of kids:")
for i in range(n):
    a=int(input())
    k.append(a)
print("enter the position of chocolate shelf:")
for i in range(n):
    b=int(input())
    c.append(b)
k.sort()
c.sort()
diff=[]
for i in range(n):
    d=abs(k[i]-c[i])
    diff.append(d)

for i in range(n):
    print("kid ",i+1," has moved ",diff[i]," steps to reach chocolate at position ",c[i]," from ",k[i])
print("the maximum time taken by those kids to reach their shelves is:",max(diff))` },
            { type: 'markdown', content: '##MiniMax' },
            { type: 'code', content: `import math

def minimax(cur_depth, node_index, max_turn, scores, target_depth, b_factor):
    if cur_depth == target_depth:
        return scores[node_index]
    if (max_turn):
        largest = None
        for i in range(b_factor):
            index = node_index * b_factor + i
            if index >= len(scores):
                continue
            cur = minimax(cur_depth + 1, index, False, scores, target_depth, b_factor)
            if largest is None or cur > largest:
                largest = cur
        return largest
    else:
        smallest = None
        for i in range(b_factor):
            index = node_index * b_factor + i
            if index >= len(scores):
                continue
            cur = minimax(cur_depth + 1, index, True, scores, target_depth, b_factor)
            if smallest is None or cur < smallest:
                smallest = cur
        return smallest

scores = [int(s) for s in input("Enter the scores: ").split()]
b_factor = int(input("enter the branching factor: "))
player = int(input("maximizer or minimizer? (Enter 1 for maximizer and 0 for minimizer): "))
print(player)
tree_depth = math.ceil(math.log(len(scores), b_factor))
print("the optimal value is:", end="")
print(minimax(0, 0, player, scores, tree_depth, b_factor))` },
            { type: 'markdown', content: '##N-Queen' },
            { type: 'code', content: `def solve_nqueens(board_size):
    def is_safe(board, row, col):
        for i in range(row):
            if board[i] == col or abs(board[i] - col) == row - i:
                return False
        return True

    def solve_nqueens_util(board, row, solutions):
        if row == board_size:
            solutions.append(board.copy())
            return
        for col in range(board_size):
            if is_safe(board, row, col):
                board[row] = col
                solve_nqueens_util(board, row+1, solutions)
    solutions = []
    board = [0]*board_size
    solve_nqueens_util(board,0,solutions)
    return solutions

if __name__ =="__main__":
    try:
        board_size = int(input("Enter chessboard size : "))
        if board_size <= 0:
            print("Board size must be a positive integer")
        else:
            solutions = solve_nqueens(board_size)
            print(f"Found {len(solutions)} solutions : ")
            for i, solution in enumerate(solutions):
                print(f"Solution {i+1}: {solution}")
    except ValueError:
        print("Invalid Output")` },
            { type: 'markdown', content: '##Path in Matrix' },
            { type: 'code', content: `mat = [
        [1,2,3],
        [4,7,8],
        [9,2,5],
    ]
V=3
sum=0
max=-1
for j in range(V):
  for i in range(V):
    if max<mat[i][j]:
      max=mat[i][j]
  print(max,end=" ")
  sum+=max
  max=-1
print('\n')
print("Sum of the path",sum)` },
            { type: 'markdown', content: '##Rotten-Oranges' },
            { type: 'code', content: `from collections import deque

def orangesRotting(grid):
    if not grid:
        return -1

    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))
            elif grid[r][c] == 1:
                fresh_count += 1

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    minutes = 0

    while queue and fresh_count > 0:
        for _ in range(len(queue)):
            x, y = queue.popleft()
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1:
                    grid[nx][ny] = 2
                    fresh_count -= 1
                    queue.append((nx, ny))
        minutes += 1

    return minutes if fresh_count == 0 else -1

# Get user input for the grid
rows = int(input("Enter the number of rows: "))
cols = int(input("Enter the number of columns: "))

grid = []
print("Enter the grid elements row-wise (0 for empty, 1 for fresh, 2 for rotten):")
for _ in range(rows):
    row = list(map(int, input().split()))
    grid.append(row)

result = orangesRotting(grid)
print("Minimum time to rot all oranges:", result)` },
            { type: 'markdown', content: '##Sparse Matrix' },
            { type: 'code', content: `def analyze_matrix(matrix):
    if not matrix:
        return 0, 0

    n = len(matrix)
    visited = [[False] * n for _ in range(n)]
    max_zeros = 0
    island_count = 0

    def dfs(x, y, is_zero_patch):
        if x < 0 or x >= n or y < 0 or y >= n or visited[x][y]:
            return 0
        if (is_zero_patch and matrix[x][y] == 1) or (not is_zero_patch and matrix[x][y] == 0):
            return 0

        visited[x][y] = True
        count = 1

        count += dfs(x + 1, y, is_zero_patch)
        count += dfs(x - 1, y, is_zero_patch)
        count += dfs(x, y + 1, is_zero_patch)
        count += dfs(x, y - 1, is_zero_patch)
        return count

    for i in range(n):
        for j in range(n):
            if matrix[i][j] == 0 and not visited[i][j]:
                max_zeros = max(max_zeros, dfs(i, j, True))
            elif matrix[i][j] == 1 and not visited[i][j]:
                island_count += 1
                dfs(i, j, False)

    return max_zeros, island_count


matrix = [
    [1, 0, 0, 1, 1],
    [0, 0, 1, 0, 0],
    [1, 0, 0, 0, 1],
    [1, 1, 1, 0, 0],
    [0, 0, 0, 1, 1]
]


largest_patch, number_of_islands = analyze_matrix(matrix)
print("The largest patch of zeros has size:", largest_patch)
print("The number of islands is:", number_of_islands)` },
            { type: 'markdown', content: '##Tic-Tac-Toe' },
            { type: 'code', content: `def tic_tac_toe(mat):
    x,o = 0,0
    coord = []
    for i in range(3):
        for j in range(3):
            if mat[i][j]==1:
                x+=1
            elif mat[i][j]==2:
                o+=1
            else:
                coord.append([i,j])
    return "Player X" if o>x else "Player O",coord
matrix = [[1, 0, 2],[0, 2, 0],[1, 0, 1]]
move,coord = tic_tac_toe(matrix)
print("Next Move Belongs to",move)
print("Available Moves :",coord)` },
            { type: 'markdown', content: '##UCS' },
            { type: 'code', content: `import heapq
import networkx as nx
import matplotlib.pyplot as plt

def uniform_cost_search(graph, start, goal):

    priority_queue = [(0, start)]

    visited = {start: (0, None)}

    while priority_queue:

        current_cost, current_node = heapq.heappop(priority_queue)


        if current_node == goal:
            return current_cost, reconstruct_path(visited, start, goal)


        for neighbor, cost in graph[current_node]:
            total_cost = current_cost + cost

            if neighbor not in visited or total_cost < visited[neighbor][0]:
                visited[neighbor] = (total_cost, current_node)
                heapq.heappush(priority_queue, (total_cost, neighbor))


    return None

def reconstruct_path(visited, start, goal):

    path = []
    current = goal
    while current is not None:
        path.append(current)
        current = visited[current][1]
    path.reverse()
    return path

def visualize_graph(graph, path=None):
    G = nx.DiGraph()

    for node, edges in graph.items():
        for neighbor, cost in edges:
            G.add_edge(node, neighbor, weight=cost)

    pos = nx.spring_layout(G)

    plt.figure(figsize=(6, 6))
    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=15, font_weight='bold', edge_color='gray')
    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_size=12)

    if path:
        path_edges = list(zip(path, path[1:]))
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2.5)

    plt.title("Uniform Cost Search Path Visualization")
    plt.show()

def get_graph_input() -> dict[str, list[tuple[str, int]]]:
    n = int(input("Enter number of vertices: "))
    graph = {}

    for _ in range(n):
        d = input("Enter node value and connected vertices with weights (e.g., A B:1 C:4): ")
        v, *connections = d.split()
        graph[v] = []

        for conn in connections:
            node, weight = conn.split(":")
            graph[v].append((node, int(weight)))

    return graph


graph=get_graph_input()
start_node = input('Enter the starting node:')
goal_node = input('Enter the Goal node:')
result = uniform_cost_search(graph, start_node, goal_node)

if result:
    total_cost, path = result
    print(f"Least cost path from {start_node} to {goal_node}: {' -> '.join(path)} with total cost {total_cost}")
    visualize_graph(graph, path)
else:
    print(f"No path found from {start_node} to {goal_node}")` },
            { type: 'markdown', content: '##Water Connection' },
            { type: 'code', content: `def find_min_weight_paths(num_nodes, connections):

    parents = [0] * (num_nodes + 1)
    weights = [0] * (num_nodes + 1)
    children = [0] * (num_nodes + 1)

    for start, end, weight in connections:
        children[start] = end
        weights[start] = weight
        parents[end] = start

    min_weight_paths = []
    for node in range(1, num_nodes + 1):
        if parents[node] == 0 and children[node]:  # Check if it's a root node with children.
            min_weight = float('inf')
            current_node = node

            while children[current_node] != 0:
                min_weight = min(min_weight, weights[current_node])
                current_node = children[current_node]

            min_weight_paths.append((node, current_node, min_weight))

    return min_weight_paths


if __name__ == "__main__":
    num_nodes = int(input("Enter the number of nodes: "))
    num_connections = int(input("Enter the number of connections: "))

    connections = []
    print("Enter the connections (start_node end_node weight) one by one:")
    for _ in range(num_connections):
        start, end, weight = map(int, input().split())
        connections.append((start, end, weight))

    paths = find_min_weight_paths(num_nodes, connections)
    print("Number of independent paths:", len(paths))
    for start, end, min_weight in paths:
        print(f"Start Node: {start}, End Node: {end}, Minimum Weight: {min_weight}")` },
            { type: 'markdown', content: '##Water Jug' },
            { type: 'code', content: `from collections import deque

def is_goal(state, target):
    return target in state

def get_next_states(state, A, B):
    x, y = state
    return [
        (A, y),         # Fill Jug A
        (x, B),         # Fill Jug B
        (0, y),         # Empty Jug A
        (x, 0),         # Empty Jug B
        (x - min(x, B - y), y + min(x, B - y)),  # Pour A → B
        (x + min(y, A - x), y - min(y, A - x))   # Pour B → A
    ]

def bfs(A, B, target):
    visited = set()
    queue = deque()
    parent = {}

    start = (0, 0)
    queue.append(start)
    visited.add(start)
    parent[start] = None

    while queue:
        state = queue.popleft()
        if is_goal(state, target):
            # Found the goal, trace the path
            path = []
            while state:
                path.append(state)
                state = parent[state]
            path.reverse()
            return path

        for next_state in get_next_states(state, A, B):
            if next_state not in visited:
                visited.add(next_state)
                queue.append(next_state)
                parent[next_state] = state

    return None

# Example Usage
if __name__ == '__main__':
    A = 5   # Capacity of Jug A
    B = 4   # Capacity of Jug B
    target = 3

    solution = bfs(A, B, target)
    if solution:
        print("Steps to reach the target:")
        for step in solution:
            print(f"Jug A: {step[0]}L, Jug B: {step[1]}L")
    else:
        print("No solution found.")` }
        ];

        let stealthMode = true; // Changed to true for default stealth mode
        let expandedCodes = {};
        let copiedIndex = null;

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            stealthMode = true;
            renderNotebook();
            setupKeyboardShortcuts();
            setupStealthToggle();
            // Force enable stealth mode by default
            const page = document.getElementById('clipboardPage');
            page.classList.add('stealth-mode');
            const icon = document.querySelector('#stealthToggle i');
            icon.className = 'fas fa-eye-slash';
        });

        function renderNotebook() {
            const notebookElement = document.getElementById('notebook');
            notebookElement.innerHTML = notebookData.map((cell, index) => 
                `<div class="cell ${cell.type}-cell">
                    ${cell.type === 'markdown' 
                        ? `<div class="markdown-content">${cell.content}</div>`
                        : `<div class="code-cell">
                            <div class="code-header">
                                <div class="code-title" onclick="toggleCodeExpansion(${index})">
                                    <i class="fas fa-${expandedCodes[index] ? 'chevron-down' : 'chevron-right'}"></i>
                                    <span>Python</span>
                                </div>
                                <button class="copy-button" data-index="${index}">
                                    <i class="fas fa-copy"></i>
                                    Copy
                                </button>
                            </div>
                            ${expandedCodes[index] ? `
                                <pre class="code-content"><code>${cell.content}</code></pre>
                            ` : ''}
                        </div>`
                    }
                </div>`
            ).join('');

            // Add click event listeners to copy buttons
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    const content = notebookData[index].content;
                    copyToClipboard(encodeURIComponent(content), this);
                });
            });
        }

        async function copyToClipboard(encodedText, buttonElement) {
            if (!buttonElement) {
                console.error('Button element not found');
                return;
            }

            const text = decodeURIComponent(encodedText);
            let success = false;

            try {
                // Method 1: Modern Clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    success = true;
                }

                // Method 2: execCommand with textarea
                if (!success) {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        success = document.execCommand('copy');
                    } catch (err) {
                        console.error('execCommand failed:', err);
                    }
                    document.body.removeChild(textArea);
                }

                // Method 3: Fallback to manual copy
                if (!success) {
                    const response = window.prompt('Copy failed. Please copy the text manually:', text);
                    success = response !== null;
                }

                // Update button state
                if (success) {
                    const originalContent = buttonElement.innerHTML;
                    buttonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    buttonElement.classList.add('copied');
                    
                    setTimeout(() => {
                        buttonElement.innerHTML = originalContent;
                        buttonElement.classList.remove('copied');
                    }, 2000);
                }
            } catch (err) {
                console.error('Copy failed:', err);
                window.prompt('Automatic copy failed. Please copy the text manually:', text);
            }
        }

        function toggleCodeExpansion(index) {
            expandedCodes[index] = !expandedCodes[index];
            renderNotebook();
        }

        function toggleStealthMode() {
            stealthMode = !stealthMode;
            document.getElementById('clipboardPage').classList.toggle('stealth-mode');
            const indicator = document.getElementById('stealthIndicator');
            indicator.textContent = `Stealth Mode: ${stealthMode ? 'ON' : 'OFF'}`;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
            
            const icon = document.querySelector('#stealthToggle i');
            icon.className = stealthMode ? 'fas fa-eye-slash' : 'fas fa-eye';
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'Q') {
                    toggleStealthMode();
                }
            });
        }

        function setupStealthToggle() {
            document.getElementById('stealthToggle').addEventListener('click', toggleStealthMode);
        }
    </script>
</body>
</html>